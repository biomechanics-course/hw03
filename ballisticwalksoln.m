function ballisticwalk
% Perform forward simulation of ballistic walking  
  
% Instructions:
%
% 1. Use the Dynamics Workbench to generate equations of motion and
%    export them to an m-file "fballwalk" for state-derivative function.
%
% 2. Copy fballwalk into the present file, as a nested function. This
%    makes the parameter values (defined below) accessible to fballwalk.
%
% 3. Write an event function "eventballwalk" to detect the knee
%    reaching full extension, and use it to terminate the ode45 integration.
%
% 4. Copy the expressions for kinetic and potential energy into a 
%    separate function energyballwalk.
%
% 5. Run a forward simulation and verify energy conservation.


% some initial states, in order q1-q3, u1-u3   
x0 = [14; -14; -60; -50; 250; -150] * pi/180; 
% above we convert deg or deg/s into rad or rad/s
   
% Set the parameter values for simulation
lfoot = 0.25; % foot length
l1 = 0.5; l2 = 0.5; lc1 = 0.433*l1; lc2 = 0.437*l2; % segment lengths, thigh and shank
m1 = 0.097; m2 = 0.06; % segment masses as fraction of body mass
BodyMass = 65; % convert to actual mass
M0 = (m1 + m2) * BodyMass; M1 = m1 * BodyMass; M2 = m2 * BodyMass;
eta1 = 0.54*l1; eta2 = 0.735*l2; % locations of center of mass
l0 = l1 + l2; lc0 = (m1*lc1 + m2*(l1+lc2)) / (m1 + m2); % stance leg length, as defined by McMahon
I0 = M1*eta1^2 + (M2*eta2^2 + M2*l1^2) - (M1+M2)*lc0^2; % moments of inertia
I1 = M1 * eta1^2 - M1*lc1^2; I2 = M2 * eta2^2 - M2*lc2^2;
g = 9.81; % gravity  

% Notice that the initial leg configuration does not start in double
% support.

clf; axis equal; hold on; % prepare a figure window
drawlegs(x0);
pause;


% simulate ballistic walking forward for a short duration
options = odeset('events', @eventballwalk);
[ts, xs] = ode45(@fballwalk, [0 0.5], x0);

% Here is a plot of the segment angles, defined ccw from vertical
clf; subplot(131)
plot(ts, xs(:,1:3)); 
xlabel('time'); ylabel('segment angle');
legend('q1', 'q2', 'q3');

% Now check energy conservation, as a post-processing step
energies = zeros(length(ts),1);
kineticEnergies = zeros(length(ts),1);
gravPotentialEnergies = zeros(length(ts),1);

for i = 1:length(ts)
  [energies(i), kineticEnergies(i), gravPotentialEnergies(i)] = ...
    energyballwalk(xs(i,:));
end

% show all three energies
subplot(132)
plot(ts, energies, ts, kineticEnergies, ts, gravPotentialEnergies);
xlabel('time'); ylabel('energy');
legend('total energy', 'kinetic energy', 'potential energy');

% and zoom in on just total energy
subplot(133)
plot(ts, energies);
xlabel('time'); ylabel('energy');
legend('total energy');

% END OF MAIN FUNCTION

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% fballwalk goes here

function xdot = fballwalk(t, x)

% State derivative code generated by Dynamics Workbench Sun 26 Jan 2014 16:54:53
% Define constants

% Define forces: 

% State assignments
q1 = x(1); q2 = x(2); q3 = x(3); 
u1 = x(4); u2 = x(5); u3 = x(6); 

s1 = sin(q1); s2 = sin(q2); s3 = sin(q3); c1m2 = cos(q1 - q2); c1m3 = cos(q1 - q3); c2m3 = cos(q2 - q3); s1m2 = sin(q1 - q2); s1m3 = sin(q1 - q3); s2m3 = sin(q2 - q3); 

% Mass Matrix
MM = zeros(3,3);
MM(1,1) = I0 - 2*l0*lc0*M0 + M0*(l0*l0) + M1*(l0*l0) + M2*(l0*l0) + ...
M0*(lc0*lc0); MM(1,2) = -(c1m2*l0*lc1*M1) - c1m2*l0*l1*M2; MM(1,3) = ...
-(c1m3*l0*lc2*M2); 
MM(2,1) = MM(1,2); MM(2,2) = I1 + M2*(l1*l1) + M1*(lc1*lc1); MM(2,3) = ...
c2m3*l1*lc2*M2; 
MM(3,1) = MM(1,3); MM(3,2) = MM(2,3); MM(3,3) = I2 + M2*(lc2*lc2); 

% righthand side terms
rhs = zeros(3,1);
rhs(1) = -(s1*g*(-l0 + lc0)*M0) + s1*g*l0*M1 + s1*g*l0*M2 + s1m2*(l0*lc1*M1 + ...
l0*lc1*M2 - l0*(-l1 + lc1)*M2)*(u2*u2) + s1m3*l0*lc2*M2*(u3*u3); 
rhs(2) = -(s2*g*lc1*M1) - s2*g*l1*M2 + s1m2*(-(lc0*lc1*M1) + (-l0 + ...
lc0)*lc1*M1 - l1*(l0 - lc0)*M2 - l1*lc0*M2)*(u1*u1) - s2m3*l1*lc2*M2*(u3*u3); 
rhs(3) = -(s3*g*lc2*M2) + s1m3*(-(lc0*lc2*M2) + (-l0 + lc0)*lc2*M2)*(u1*u1) + ...
s2m3*((l1 - lc1)*lc2*M2 + lc1*lc2*M2)*(u2*u2); 

udot = MM\rhs;
xdot = [x(3+1:2*3); udot];

end % function

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% energyballwalk computes kinetic and potential energy
function [energy, kineticEnergy, gravPotentialEnergy] = energyballwalk(x)
  
% State assignments
q1 = x(1); q2 = x(2); q3 = x(3); 
u1 = x(4); u2 = x(5); u3 = x(6); 

s1 = sin(q1); s2 = sin(q2); s3 = sin(q3); c1m2 = cos(q1 - q2); c1m3 = cos(q1 - q3); c2m3 = cos(q2 - q3); s1m2 = sin(q1 - q2); s1m3 = sin(q1 - q3); s2m3 = sin(q2 - q3); 


kineticEnergy = (I0*(u1*u1))/2. + (I1*(u2*u2))/2. + (I2*(u3*u3))/2. + ...
  (M0*(u1*u1)*((l0 - lc0)*(l0 - lc0)))/2. + (M1*(2*c1m2*u2*(-(u1*(l0 - lc0)) - ...
  u1*lc0)*lc1 + (-(u1*(l0 - lc0)) - u1*lc0)*(-(u1*(l0 - lc0)) - u1*lc0) + ...
  u2*u2*(lc1*lc1)))/2. + (M2*(2*c1m2*(-(u1*(l0 - lc0)) - u1*lc0)*(u2*lc1 - ...
  u2*(-l1 + lc1)) + 2*c1m3*u3*(-(u1*(l0 - lc0)) - u1*lc0)*lc2 + ...
  2*c2m3*u3*(u2*lc1 - u2*(-l1 + lc1))*lc2 + (-(u1*(l0 - lc0)) - ...
  u1*lc0)*(-(u1*(l0 - lc0)) - u1*lc0) + (u2*lc1 - u2*(-l1 + lc1))*(u2*lc1 - ...
  u2*(-l1 + lc1)) + u3*u3*(lc2*lc2)))/2.;

gravPotentialEnergy = g*(l0 - lc0)*M0*cos(q1) - M1*(-(g*l0*cos(q1)) + ...
  g*lc1*cos(q2)) - M2*(-(g*l0*cos(q1)) + g*l1*cos(q2) + g*lc2*cos(q3));

energy = kineticEnergy + gravPotentialEnergy;

end % energyballwalk

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [value, direction, isterminal] = eventballwalk(x)

% WRITE A FUNCTION TO DETECT KNEE GETTING STRAIGHT

% State assignments
q1 = x(1); q2 = x(2); q3 = x(3); 
u1 = x(4); u2 = x(5); u3 = x(6); 

% swing knee angle (zero at full extension)
  value = q2 - q3;

  direction = -1; % from above

  isterminal = 1; % stop the integration

end % eventballwalk

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function drawlegs(x);
    % Use the angles to draw a stick figure of the leg configuration
    % The segment lengths should be defined in outer scope of this
    % nested function.
    % A figure window should already exist, with axis equal 
    % recommended.
    
    q1 = x(1); q2 = x(2); q3 = x(3); 

    xtoe = 0;
    xankle = xtoe - lfoot;
    xhip = xankle - (l1+l2)*sin(q1);
    xswingknee = xhip + l2*sin(q2);
    xswingankle = xswingknee + l1*sin(q3);
    xswingtoe = xswingankle + lfoot*cos(q3);
    ytoe = 0;
    yankle = ytoe;
    yhip = yankle + (l1+l2)*cos(q1);
    yswingknee = yhip - l2*cos(q2);
    yswingankle = yswingknee - l1*cos(q3);
    yswingtoe = yswingankle - lfoot*cos(q3);

    xlocations = [xtoe, xankle, xhip, xswingknee, xswingankle, xswingtoe];
    ylocations = [ytoe, yankle, yhip, yswingknee, yswingankle, yswingtoe];

    plot(xlocations, ylocations, 'linewidth', 3); % segment lines
    plot(xlocations, ylocations, '.', 'markersize', 10 ); % a dot at each joint
end % drawlegs

end % ballisticwalk 
